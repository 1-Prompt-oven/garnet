"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"intro-to-garnet","metadata":{"permalink":"/blog/intro-to-garnet","editUrl":"https://github.com/microsoft/Garnet/tree/main/website/blog/2022-11-30-introducing-garnet.md","source":"@site/blog/2022-11-30-introducing-garnet.md","title":"Introducing Garnet","description":"Hi everyone! I just wanted to start this blog with a short history of Garnet and how it","date":"2022-11-30T00:00:00.000Z","formattedDate":"November 30, 2022","tags":[{"label":"garnet","permalink":"/blog/tags/garnet"},{"label":"introduction","permalink":"/blog/tags/introduction"}],"readingTime":2.535,"hasTruncateMarker":false,"authors":[{"name":"Badrish Chandramouli","title":"Partner Research Manager, Microsoft Research","url":"https://badrish.net","imageURL":"https://badrish.net/assets/icons/badrish4.jpg","key":"badrishc"}],"frontMatter":{"slug":"intro-to-garnet","title":"Introducing Garnet","authors":"badrishc","tags":["garnet","introduction"]},"unlisted":false},"content":"Hi everyone! I just wanted to start this blog with a short history of Garnet and how it\\ncame to exist. At Microsoft Research, we have been working on storage technology\\nfor a while. In 2017, we proposed a new key-value store design based on epoch protection and\\na powerful storage API. This project, called FASTER, was open-sourced in 2018 and gained a\\nlot of traction within Microsoft and in the larger community. We build several follow-on\\ncapabilities such as recoverability (CPR) and serverless support (Netherite), and the \\nproject was widely adopted.\\n\\nAround 2021, we noticed a huge interest in remote cache-stores, particularly using APIs\\nsuch as the RESP API of Redis. Developers at Microsoft loved the flexibility of both the\\nAPI and the deployment model as a separate process/service. The cost savings compared to\\naccessing cloud databases directly drove the adoption of caching layers, and these soon\\ngrew to take up a significant portion of the operating cost of large services. When the\\npandemic hit and online service usage spiked, there was a strong need for lowering costs\\nand improving performance (throughput and latency) for such caching layers.\\n\\nWe took on the challenge of building a new system, called Garnet, which could provide\\nextremely high performance end-to-end in a client-server setup while allowing clients\\nto remain largely unmodified by adopting RESP, the most popular wire protocols out there.\\nAfter a lot of design effort, we came up with a server threading model that could indeed \\nmake a huge end-to-end difference, often by orders-of-magnitude, in performance for \\nbasic get and set operations, with unmodified client code. This gave us the confidence to \\nbuild out Garnet\'s feature set towards use in real scenarios.\\n\\nThe next question was API coverage. The Redis API is vast, and we were just a small research\\nteam. Thankfully, our stack was built on .NET, which made tremendous advances in both performance\\nand richness of libraries. We designed a generic yet powerful way to define and use custom\\ndata structures, and were able to quickly implement complex datatypes such as Sorted Set, List,\\nand Hash by reusing data structures in C#. We then built complex structures such as HyperLogLog\\nand Bitmap as well, and added transactions and extensibility features.\\n\\nThe next requirement was scale-out and recovery, for which we designed write-ahead operation logging,\\nsharding capability, replication, and key migration for dynamic scale-out. By keeping basic compatibility\\nwith the Redis API, we were able to add these features in a way that existing client code could\\nbe largely unchanged.\\n\\nAfter thousands of unit tests and a couple of years working with first-party customers at Microsoft\\ndeploying Garnet in production (more on this in future blog posts!), we felt it was time to release \\nit publicly, just like we did with FASTER 5 years back. We wanted developers across the planet to \\nbenefit from this powerful technology and contribute back to the codebase as well. We felt that \\nthe modern C# codebase would be particularly attractive here, in terms of ease of expansion, \\nmaintenance, and contribution."}]}')}}]);